/*******************************************************************************
* Copyright (c) 2009, 2011 Overture Team and others.
*
* Overture is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* Overture is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with Overture.  If not, see <http://www.gnu.org/licenses/>.
*
* The Overture Tool web-site: http://overturetool.org/
*******************************************************************************/

/* This file was generated by ASTcreator (http://www.lausdahl.com/). */

package org.destecs.script.ast.analysis;


import org.destecs.script.ast.expressions.AMsTimeunit;
import org.destecs.script.ast.expressions.binop.AModBinop;
import java.lang.Boolean;
import org.destecs.script.ast.statement.AQuitStm;
import java.lang.Long;
import org.destecs.script.ast.preprocessing.AScriptInclude;
import org.destecs.script.ast.types.AIntType;
import org.destecs.script.ast.expressions.ASTimeunit;
import org.destecs.script.ast.expressions.ABoolSingleExp;
import org.destecs.script.ast.expressions.PExp;
import java.lang.Double;
import org.destecs.script.ast.statement.AErrorMessageStm;
import org.destecs.script.ast.expressions.binop.AMoreEqualBinop;
import org.destecs.script.ast.statement.APrintMessageStm;
import org.destecs.script.ast.expressions.binop.ADivideBinop;
import org.destecs.script.ast.node.INode;
import org.destecs.script.ast.statement.AAssignStm;
import org.destecs.script.ast.types.PType;
import org.destecs.script.ast.expressions.binop.PBinop;
import org.destecs.script.ast.expressions.binop.APlusBinop;
import org.destecs.script.ast.expressions.binop.ADifferentBinop;
import org.destecs.script.ast.expressions.AHTimeunit;
import org.destecs.script.ast.ACtDomain;
import org.destecs.script.ast.types.ATimeType;
import org.destecs.script.ast.analysis.intf.IAnalysis;
import java.util.List;
import org.destecs.script.ast.expressions.binop.AEqualBinop;
import java.lang.Integer;
import org.destecs.script.ast.statement.PStm;
import org.destecs.script.ast.expressions.binop.AForBinop;
import org.destecs.script.ast.expressions.binop.AMultiplyBinop;
import org.destecs.script.ast.statement.AWarnMessageStm;
import org.destecs.script.ast.expressions.AIdentifierSingleExp;
import org.destecs.script.ast.expressions.binop.AMinusBinop;
import org.destecs.script.ast.expressions.PTimeunit;
import org.destecs.script.ast.expressions.AMTimeunit;
import org.destecs.script.ast.PDomain;
import org.destecs.script.ast.preprocessing.PInclude;
import org.destecs.script.ast.expressions.ABinaryExp;
import org.destecs.script.ast.expressions.AUnaryExp;
import org.destecs.script.ast.expressions.AUsTimeunit;
import org.destecs.script.ast.expressions.unop.ACeilUnop;
import org.destecs.script.ast.ADeDomain;
import org.destecs.script.ast.expressions.binop.AOrBinop;
import org.destecs.script.ast.expressions.ANumericalSingleExp;
import org.destecs.script.ast.node.tokens.TInt;
import org.destecs.script.ast.expressions.unop.AMinusUnop;
import org.destecs.script.ast.expressions.binop.ADivBinop;
import org.destecs.script.ast.statement.AWhenStm;
import org.destecs.script.ast.expressions.unop.PUnop;
import org.destecs.script.ast.expressions.binop.AAndBinop;
import org.destecs.script.ast.types.ARealType;
import org.destecs.script.ast.expressions.unop.AFloorUnop;
import org.destecs.script.ast.expressions.ASystemTimeSingleExp;
import java.util.ArrayList;
import org.destecs.script.ast.expressions.SSingleExp;
import org.destecs.script.ast.statement.SMessageStm;
import org.destecs.script.ast.expressions.binop.AEquivBinop;
import java.lang.String;
import org.destecs.script.ast.expressions.ATimeSingleExp;
import org.destecs.script.ast.expressions.unop.AAbsUnop;
import org.destecs.script.ast.expressions.binop.ALessEqualBinop;
import org.destecs.script.ast.statement.ARevertStm;
import org.destecs.script.ast.expressions.binop.ALessThanBinop;
import org.destecs.script.ast.types.ABoolType;
import org.destecs.script.ast.expressions.binop.AMoreThanBinop;
import org.destecs.script.ast.expressions.binop.AImpliesBinop;
import org.destecs.script.ast.expressions.unop.AAddUnop;
import org.destecs.script.ast.node.IToken;
import java.util.Queue;


/**
* Generated file by AST Creator
* @author Kenneth Lausdahl
*
*/
public class DepthFirstAnalysisAdaptor implements IAnalysis
{
	private static final long serialVersionUID = 1L;

	protected Queue _queue = new java.util.LinkedList<INode>();

	/**
	* Creates a new {@code DepthFirstAnalysisAdaptor} node with the given nodes as children.
	* The basic child nodes are removed from their previous parents.
	* @param queue_ the {@link Queue} node for the {@code queue} child of this {@link DepthFirstAnalysisAdaptor} node
	*/
	public DepthFirstAnalysisAdaptor(Queue queue_)
	{
		super();
		this.setQueue(queue_);

	}


	/**
	 * Creates a new {@link DepthFirstAnalysisAdaptor} node with no children.
	 */
	public DepthFirstAnalysisAdaptor()
	{

	}




	/**
	 * Essentially this.toString().equals(o.toString()).
	**/
	@Override
	public boolean equals(Object o) {
	if (o != null && o instanceof DepthFirstAnalysisAdaptor)
	 return toString().equals(o.toString());
	return false; }
	
	/**
	 * Sets the {@code _queue} child of this {@link DepthFirstAnalysisAdaptor} node.
	 * @param value the new {@code _queue} child of this {@link DepthFirstAnalysisAdaptor} node
	*/
	public void setQueue(Queue value)
	{

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void caseTInt(TInt node)
	{
		if(_queue.contains(node))
		{ //already visiting this node from other path
			return;
		}
		_queue.add(node);
		inTInt(node);


		outTInt(node);
		_queue.remove(node);

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void inTInt(TInt node)
	{
		defaultInIToken(node);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void outTInt(TInt node)
	{
		defaultOutIToken(node);
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void caseDouble(Double node)
	{
		if(_queue.contains(node))
		{ //already visiting this node from other path
			return;
		}
		_queue.add(node);
		inDouble(node);


		outDouble(node);
		_queue.remove(node);

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void inDouble(Double node)
	{

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void outDouble(Double node)
	{

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void caseBoolean(Boolean node)
	{
		if(_queue.contains(node))
		{ //already visiting this node from other path
			return;
		}
		_queue.add(node);
		inBoolean(node);


		outBoolean(node);
		_queue.remove(node);

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void inBoolean(Boolean node)
	{

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void outBoolean(Boolean node)
	{

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void caseInteger(Integer node)
	{
		if(_queue.contains(node))
		{ //already visiting this node from other path
			return;
		}
		_queue.add(node);
		inInteger(node);


		outInteger(node);
		_queue.remove(node);

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void inInteger(Integer node)
	{

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void outInteger(Integer node)
	{

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void caseString(String node)
	{
		if(_queue.contains(node))
		{ //already visiting this node from other path
			return;
		}
		_queue.add(node);
		inString(node);


		outString(node);
		_queue.remove(node);

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void inString(String node)
	{

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void outString(String node)
	{

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void caseLong(Long node)
	{
		if(_queue.contains(node))
		{ //already visiting this node from other path
			return;
		}
		_queue.add(node);
		inLong(node);


		outLong(node);
		_queue.remove(node);

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void inLong(Long node)
	{

	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void outLong(Long node)
	{

	}


	/**
	* Called by the {@link PUnop} node from {@link PUnop#apply(IAnalysis)}.
	* @param node the calling {@link PUnop} node
	*/
	public void defaultInPUnop(PUnop node)
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PUnop} node from {@link PUnop#apply(IAnalysis)}.
	* @param node the calling {@link PUnop} node
	*/
	public void defaultOutPUnop(PUnop node)
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link PUnop} node from {@link PUnop#apply(IAnalysis)}.
	* @param node the calling {@link PUnop} node
	*/
	public void inPUnop(PUnop node)
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PUnop} node from {@link PUnop#apply(IAnalysis)}.
	* @param node the calling {@link PUnop} node
	*/
	public void outPUnop(PUnop node)
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link AAddUnop} node from {@link AAddUnop#apply(IAnalysis)}.
	* @param node the calling {@link AAddUnop} node
	*/
	public void caseAAddUnop(AAddUnop node)
	{
		if(_queue.contains(node))
		{ //already visiting this node from other path
			return;
		}
		_queue.add(node);
		inAAddUnop(node);


		outAAddUnop(node);
		_queue.remove(node);

	}


	/**
	* Called by the {@link AAddUnop} node from {@link AAddUnop#apply(IAnalysis)}.
	* @param node the calling {@link AAddUnop} node
	*/
	public void inAAddUnop(AAddUnop node)
	{
		defaultInPUnop(node);
	}


	/**
	* Called by the {@link AAddUnop} node from {@link AAddUnop#apply(IAnalysis)}.
	* @param node the calling {@link AAddUnop} node
	*/
	public void outAAddUnop(AAddUnop node)
	{
		defaultOutPUnop(node);
	}


	/**
	* Called by the {@link AMinusUnop} node from {@link AMinusUnop#apply(IAnalysis)}.
	* @param node the calling {@link AMinusUnop} node
	*/
	public void caseAMinusUnop(AMinusUnop node)
	{
		if(_queue.contains(node))
		{ //already visiting this node from other path
			return;
		}
		_queue.add(node);
		inAMinusUnop(node);


		outAMinusUnop(node);
		_queue.remove(node);

	}


	/**
	* Called by the {@link AMinusUnop} node from {@link AMinusUnop#apply(IAnalysis)}.
	* @param node the calling {@link AMinusUnop} node
	*/
	public void inAMinusUnop(AMinusUnop node)
	{
		defaultInPUnop(node);
	}


	/**
	* Called by the {@link AMinusUnop} node from {@link AMinusUnop#apply(IAnalysis)}.
	* @param node the calling {@link AMinusUnop} node
	*/
	public void outAMinusUnop(AMinusUnop node)
	{
		defaultOutPUnop(node);
	}


	/**
	* Called by the {@link AAbsUnop} node from {@link AAbsUnop#apply(IAnalysis)}.
	* @param node the calling {@link AAbsUnop} node
	*/
	public void caseAAbsUnop(AAbsUnop node)
	{
		if(_queue.contains(node))
		{ //already visiting this node from other path
			return;
		}
		_queue.add(node);
		inAAbsUnop(node);


		outAAbsUnop(node);
		_queue.remove(node);

	}


	/**
	* Called by the {@link AAbsUnop} node from {@link AAbsUnop#apply(IAnalysis)}.
	* @param node the calling {@link AAbsUnop} node
	*/
	public void inAAbsUnop(AAbsUnop node)
	{
		defaultInPUnop(node);
	}


	/**
	* Called by the {@link AAbsUnop} node from {@link AAbsUnop#apply(IAnalysis)}.
	* @param node the calling {@link AAbsUnop} node
	*/
	public void outAAbsUnop(AAbsUnop node)
	{
		defaultOutPUnop(node);
	}


	/**
	* Called by the {@link AFloorUnop} node from {@link AFloorUnop#apply(IAnalysis)}.
	* @param node the calling {@link AFloorUnop} node
	*/
	public void caseAFloorUnop(AFloorUnop node)
	{
		if(_queue.contains(node))
		{ //already visiting this node from other path
			return;
		}
		_queue.add(node);
		inAFloorUnop(node);


		outAFloorUnop(node);
		_queue.remove(node);

	}


	/**
	* Called by the {@link AFloorUnop} node from {@link AFloorUnop#apply(IAnalysis)}.
	* @param node the calling {@link AFloorUnop} node
	*/
	public void inAFloorUnop(AFloorUnop node)
	{
		defaultInPUnop(node);
	}


	/**
	* Called by the {@link AFloorUnop} node from {@link AFloorUnop#apply(IAnalysis)}.
	* @param node the calling {@link AFloorUnop} node
	*/
	public void outAFloorUnop(AFloorUnop node)
	{
		defaultOutPUnop(node);
	}


	/**
	* Called by the {@link ACeilUnop} node from {@link ACeilUnop#apply(IAnalysis)}.
	* @param node the calling {@link ACeilUnop} node
	*/
	public void caseACeilUnop(ACeilUnop node)
	{
		if(_queue.contains(node))
		{ //already visiting this node from other path
			return;
		}
		_queue.add(node);
		inACeilUnop(node);


		outACeilUnop(node);
		_queue.remove(node);

	}


	/**
	* Called by the {@link ACeilUnop} node from {@link ACeilUnop#apply(IAnalysis)}.
	* @param node the calling {@link ACeilUnop} node
	*/
	public void inACeilUnop(ACeilUnop node)
	{
		defaultInPUnop(node);
	}


	/**
	* Called by the {@link ACeilUnop} node from {@link ACeilUnop#apply(IAnalysis)}.
	* @param node the calling {@link ACeilUnop} node
	*/
	public void outACeilUnop(ACeilUnop node)
	{
		defaultOutPUnop(node);
	}


	/**
	* Called by the {@link PBinop} node from {@link PBinop#apply(IAnalysis)}.
	* @param node the calling {@link PBinop} node
	*/
	public void defaultInPBinop(PBinop node)
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PBinop} node from {@link PBinop#apply(IAnalysis)}.
	* @param node the calling {@link PBinop} node
	*/
	public void defaultOutPBinop(PBinop node)
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link PBinop} node from {@link PBinop#apply(IAnalysis)}.
	* @param node the calling {@link PBinop} node
	*/
	public void inPBinop(PBinop node)
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PBinop} node from {@link PBinop#apply(IAnalysis)}.
	* @param node the calling {@link PBinop} node
	*/
	public void outPBinop(PBinop node)
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link APlusBinop} node from {@link APlusBinop#apply(IAnalysis)}.
	* @param node the calling {@link APlusBinop} node
	*/
	public void caseAPlusBinop(APlusBinop node)
	{
		if(_queue.contains(node))
		{ //already visiting this node from other path
			return;
		}
		_queue.add(node);
		inAPlusBinop(node);


		outAPlusBinop(node);
		_queue.remove(node);

	}


	/**
	* Called by the {@link APlusBinop} node from {@link APlusBinop#apply(IAnalysis)}.
	* @param node the calling {@link APlusBinop} node
	*/
	public void inAPlusBinop(APlusBinop node)
	{
		defaultInPBinop(node);
	}


	/**
	* Called by the {@link APlusBinop} node from {@link APlusBinop#apply(IAnalysis)}.
	* @param node the calling {@link APlusBinop} node
	*/
	public void outAPlusBinop(APlusBinop node)
	{
		defaultOutPBinop(node);
	}


	/**
	* Called by the {@link AMinusBinop} node from {@link AMinusBinop#apply(IAnalysis)}.
	* @param node the calling {@link AMinusBinop} node
	*/
	public void caseAMinusBinop(AMinusBinop node)
	{
		if(_queue.contains(node))
		{ //already visiting this node from other path
			return;
		}
		_queue.add(node);
		inAMinusBinop(node);


		outAMinusBinop(node);
		_queue.remove(node);

	}


	/**
	* Called by the {@link AMinusBinop} node from {@link AMinusBinop#apply(IAnalysis)}.
	* @param node the calling {@link AMinusBinop} node
	*/
	public void inAMinusBinop(AMinusBinop node)
	{
		defaultInPBinop(node);
	}


	/**
	* Called by the {@link AMinusBinop} node from {@link AMinusBinop#apply(IAnalysis)}.
	* @param node the calling {@link AMinusBinop} node
	*/
	public void outAMinusBinop(AMinusBinop node)
	{
		defaultOutPBinop(node);
	}


	/**
	* Called by the {@link AMultiplyBinop} node from {@link AMultiplyBinop#apply(IAnalysis)}.
	* @param node the calling {@link AMultiplyBinop} node
	*/
	public void caseAMultiplyBinop(AMultiplyBinop node)
	{
		if(_queue.contains(node))
		{ //already visiting this node from other path
			return;
		}
		_queue.add(node);
		inAMultiplyBinop(node);


		outAMultiplyBinop(node);
		_queue.remove(node);

	}


	/**
	* Called by the {@link AMultiplyBinop} node from {@link AMultiplyBinop#apply(IAnalysis)}.
	* @param node the calling {@link AMultiplyBinop} node
	*/
	public void inAMultiplyBinop(AMultiplyBinop node)
	{
		defaultInPBinop(node);
	}


	/**
	* Called by the {@link AMultiplyBinop} node from {@link AMultiplyBinop#apply(IAnalysis)}.
	* @param node the calling {@link AMultiplyBinop} node
	*/
	public void outAMultiplyBinop(AMultiplyBinop node)
	{
		defaultOutPBinop(node);
	}


	/**
	* Called by the {@link ADivideBinop} node from {@link ADivideBinop#apply(IAnalysis)}.
	* @param node the calling {@link ADivideBinop} node
	*/
	public void caseADivideBinop(ADivideBinop node)
	{
		if(_queue.contains(node))
		{ //already visiting this node from other path
			return;
		}
		_queue.add(node);
		inADivideBinop(node);


		outADivideBinop(node);
		_queue.remove(node);

	}


	/**
	* Called by the {@link ADivideBinop} node from {@link ADivideBinop#apply(IAnalysis)}.
	* @param node the calling {@link ADivideBinop} node
	*/
	public void inADivideBinop(ADivideBinop node)
	{
		defaultInPBinop(node);
	}


	/**
	* Called by the {@link ADivideBinop} node from {@link ADivideBinop#apply(IAnalysis)}.
	* @param node the calling {@link ADivideBinop} node
	*/
	public void outADivideBinop(ADivideBinop node)
	{
		defaultOutPBinop(node);
	}


	/**
	* Called by the {@link ADivBinop} node from {@link ADivBinop#apply(IAnalysis)}.
	* @param node the calling {@link ADivBinop} node
	*/
	public void caseADivBinop(ADivBinop node)
	{
		if(_queue.contains(node))
		{ //already visiting this node from other path
			return;
		}
		_queue.add(node);
		inADivBinop(node);


		outADivBinop(node);
		_queue.remove(node);

	}


	/**
	* Called by the {@link ADivBinop} node from {@link ADivBinop#apply(IAnalysis)}.
	* @param node the calling {@link ADivBinop} node
	*/
	public void inADivBinop(ADivBinop node)
	{
		defaultInPBinop(node);
	}


	/**
	* Called by the {@link ADivBinop} node from {@link ADivBinop#apply(IAnalysis)}.
	* @param node the calling {@link ADivBinop} node
	*/
	public void outADivBinop(ADivBinop node)
	{
		defaultOutPBinop(node);
	}


	/**
	* Called by the {@link AModBinop} node from {@link AModBinop#apply(IAnalysis)}.
	* @param node the calling {@link AModBinop} node
	*/
	public void caseAModBinop(AModBinop node)
	{
		if(_queue.contains(node))
		{ //already visiting this node from other path
			return;
		}
		_queue.add(node);
		inAModBinop(node);


		outAModBinop(node);
		_queue.remove(node);

	}


	/**
	* Called by the {@link AModBinop} node from {@link AModBinop#apply(IAnalysis)}.
	* @param node the calling {@link AModBinop} node
	*/
	public void inAModBinop(AModBinop node)
	{
		defaultInPBinop(node);
	}


	/**
	* Called by the {@link AModBinop} node from {@link AModBinop#apply(IAnalysis)}.
	* @param node the calling {@link AModBinop} node
	*/
	public void outAModBinop(AModBinop node)
	{
		defaultOutPBinop(node);
	}


	/**
	* Called by the {@link ALessThanBinop} node from {@link ALessThanBinop#apply(IAnalysis)}.
	* @param node the calling {@link ALessThanBinop} node
	*/
	public void caseALessThanBinop(ALessThanBinop node)
	{
		if(_queue.contains(node))
		{ //already visiting this node from other path
			return;
		}
		_queue.add(node);
		inALessThanBinop(node);


		outALessThanBinop(node);
		_queue.remove(node);

	}


	/**
	* Called by the {@link ALessThanBinop} node from {@link ALessThanBinop#apply(IAnalysis)}.
	* @param node the calling {@link ALessThanBinop} node
	*/
	public void inALessThanBinop(ALessThanBinop node)
	{
		defaultInPBinop(node);
	}


	/**
	* Called by the {@link ALessThanBinop} node from {@link ALessThanBinop#apply(IAnalysis)}.
	* @param node the calling {@link ALessThanBinop} node
	*/
	public void outALessThanBinop(ALessThanBinop node)
	{
		defaultOutPBinop(node);
	}


	/**
	* Called by the {@link ALessEqualBinop} node from {@link ALessEqualBinop#apply(IAnalysis)}.
	* @param node the calling {@link ALessEqualBinop} node
	*/
	public void caseALessEqualBinop(ALessEqualBinop node)
	{
		if(_queue.contains(node))
		{ //already visiting this node from other path
			return;
		}
		_queue.add(node);
		inALessEqualBinop(node);


		outALessEqualBinop(node);
		_queue.remove(node);

	}


	/**
	* Called by the {@link ALessEqualBinop} node from {@link ALessEqualBinop#apply(IAnalysis)}.
	* @param node the calling {@link ALessEqualBinop} node
	*/
	public void inALessEqualBinop(ALessEqualBinop node)
	{
		defaultInPBinop(node);
	}


	/**
	* Called by the {@link ALessEqualBinop} node from {@link ALessEqualBinop#apply(IAnalysis)}.
	* @param node the calling {@link ALessEqualBinop} node
	*/
	public void outALessEqualBinop(ALessEqualBinop node)
	{
		defaultOutPBinop(node);
	}


	/**
	* Called by the {@link AMoreThanBinop} node from {@link AMoreThanBinop#apply(IAnalysis)}.
	* @param node the calling {@link AMoreThanBinop} node
	*/
	public void caseAMoreThanBinop(AMoreThanBinop node)
	{
		if(_queue.contains(node))
		{ //already visiting this node from other path
			return;
		}
		_queue.add(node);
		inAMoreThanBinop(node);


		outAMoreThanBinop(node);
		_queue.remove(node);

	}


	/**
	* Called by the {@link AMoreThanBinop} node from {@link AMoreThanBinop#apply(IAnalysis)}.
	* @param node the calling {@link AMoreThanBinop} node
	*/
	public void inAMoreThanBinop(AMoreThanBinop node)
	{
		defaultInPBinop(node);
	}


	/**
	* Called by the {@link AMoreThanBinop} node from {@link AMoreThanBinop#apply(IAnalysis)}.
	* @param node the calling {@link AMoreThanBinop} node
	*/
	public void outAMoreThanBinop(AMoreThanBinop node)
	{
		defaultOutPBinop(node);
	}


	/**
	* Called by the {@link AMoreEqualBinop} node from {@link AMoreEqualBinop#apply(IAnalysis)}.
	* @param node the calling {@link AMoreEqualBinop} node
	*/
	public void caseAMoreEqualBinop(AMoreEqualBinop node)
	{
		if(_queue.contains(node))
		{ //already visiting this node from other path
			return;
		}
		_queue.add(node);
		inAMoreEqualBinop(node);


		outAMoreEqualBinop(node);
		_queue.remove(node);

	}


	/**
	* Called by the {@link AMoreEqualBinop} node from {@link AMoreEqualBinop#apply(IAnalysis)}.
	* @param node the calling {@link AMoreEqualBinop} node
	*/
	public void inAMoreEqualBinop(AMoreEqualBinop node)
	{
		defaultInPBinop(node);
	}


	/**
	* Called by the {@link AMoreEqualBinop} node from {@link AMoreEqualBinop#apply(IAnalysis)}.
	* @param node the calling {@link AMoreEqualBinop} node
	*/
	public void outAMoreEqualBinop(AMoreEqualBinop node)
	{
		defaultOutPBinop(node);
	}


	/**
	* Called by the {@link AEqualBinop} node from {@link AEqualBinop#apply(IAnalysis)}.
	* @param node the calling {@link AEqualBinop} node
	*/
	public void caseAEqualBinop(AEqualBinop node)
	{
		if(_queue.contains(node))
		{ //already visiting this node from other path
			return;
		}
		_queue.add(node);
		inAEqualBinop(node);


		outAEqualBinop(node);
		_queue.remove(node);

	}


	/**
	* Called by the {@link AEqualBinop} node from {@link AEqualBinop#apply(IAnalysis)}.
	* @param node the calling {@link AEqualBinop} node
	*/
	public void inAEqualBinop(AEqualBinop node)
	{
		defaultInPBinop(node);
	}


	/**
	* Called by the {@link AEqualBinop} node from {@link AEqualBinop#apply(IAnalysis)}.
	* @param node the calling {@link AEqualBinop} node
	*/
	public void outAEqualBinop(AEqualBinop node)
	{
		defaultOutPBinop(node);
	}


	/**
	* Called by the {@link ADifferentBinop} node from {@link ADifferentBinop#apply(IAnalysis)}.
	* @param node the calling {@link ADifferentBinop} node
	*/
	public void caseADifferentBinop(ADifferentBinop node)
	{
		if(_queue.contains(node))
		{ //already visiting this node from other path
			return;
		}
		_queue.add(node);
		inADifferentBinop(node);


		outADifferentBinop(node);
		_queue.remove(node);

	}


	/**
	* Called by the {@link ADifferentBinop} node from {@link ADifferentBinop#apply(IAnalysis)}.
	* @param node the calling {@link ADifferentBinop} node
	*/
	public void inADifferentBinop(ADifferentBinop node)
	{
		defaultInPBinop(node);
	}


	/**
	* Called by the {@link ADifferentBinop} node from {@link ADifferentBinop#apply(IAnalysis)}.
	* @param node the calling {@link ADifferentBinop} node
	*/
	public void outADifferentBinop(ADifferentBinop node)
	{
		defaultOutPBinop(node);
	}


	/**
	* Called by the {@link AOrBinop} node from {@link AOrBinop#apply(IAnalysis)}.
	* @param node the calling {@link AOrBinop} node
	*/
	public void caseAOrBinop(AOrBinop node)
	{
		if(_queue.contains(node))
		{ //already visiting this node from other path
			return;
		}
		_queue.add(node);
		inAOrBinop(node);


		outAOrBinop(node);
		_queue.remove(node);

	}


	/**
	* Called by the {@link AOrBinop} node from {@link AOrBinop#apply(IAnalysis)}.
	* @param node the calling {@link AOrBinop} node
	*/
	public void inAOrBinop(AOrBinop node)
	{
		defaultInPBinop(node);
	}


	/**
	* Called by the {@link AOrBinop} node from {@link AOrBinop#apply(IAnalysis)}.
	* @param node the calling {@link AOrBinop} node
	*/
	public void outAOrBinop(AOrBinop node)
	{
		defaultOutPBinop(node);
	}


	/**
	* Called by the {@link AAndBinop} node from {@link AAndBinop#apply(IAnalysis)}.
	* @param node the calling {@link AAndBinop} node
	*/
	public void caseAAndBinop(AAndBinop node)
	{
		if(_queue.contains(node))
		{ //already visiting this node from other path
			return;
		}
		_queue.add(node);
		inAAndBinop(node);


		outAAndBinop(node);
		_queue.remove(node);

	}


	/**
	* Called by the {@link AAndBinop} node from {@link AAndBinop#apply(IAnalysis)}.
	* @param node the calling {@link AAndBinop} node
	*/
	public void inAAndBinop(AAndBinop node)
	{
		defaultInPBinop(node);
	}


	/**
	* Called by the {@link AAndBinop} node from {@link AAndBinop#apply(IAnalysis)}.
	* @param node the calling {@link AAndBinop} node
	*/
	public void outAAndBinop(AAndBinop node)
	{
		defaultOutPBinop(node);
	}


	/**
	* Called by the {@link AImpliesBinop} node from {@link AImpliesBinop#apply(IAnalysis)}.
	* @param node the calling {@link AImpliesBinop} node
	*/
	public void caseAImpliesBinop(AImpliesBinop node)
	{
		if(_queue.contains(node))
		{ //already visiting this node from other path
			return;
		}
		_queue.add(node);
		inAImpliesBinop(node);


		outAImpliesBinop(node);
		_queue.remove(node);

	}


	/**
	* Called by the {@link AImpliesBinop} node from {@link AImpliesBinop#apply(IAnalysis)}.
	* @param node the calling {@link AImpliesBinop} node
	*/
	public void inAImpliesBinop(AImpliesBinop node)
	{
		defaultInPBinop(node);
	}


	/**
	* Called by the {@link AImpliesBinop} node from {@link AImpliesBinop#apply(IAnalysis)}.
	* @param node the calling {@link AImpliesBinop} node
	*/
	public void outAImpliesBinop(AImpliesBinop node)
	{
		defaultOutPBinop(node);
	}


	/**
	* Called by the {@link AEquivBinop} node from {@link AEquivBinop#apply(IAnalysis)}.
	* @param node the calling {@link AEquivBinop} node
	*/
	public void caseAEquivBinop(AEquivBinop node)
	{
		if(_queue.contains(node))
		{ //already visiting this node from other path
			return;
		}
		_queue.add(node);
		inAEquivBinop(node);


		outAEquivBinop(node);
		_queue.remove(node);

	}


	/**
	* Called by the {@link AEquivBinop} node from {@link AEquivBinop#apply(IAnalysis)}.
	* @param node the calling {@link AEquivBinop} node
	*/
	public void inAEquivBinop(AEquivBinop node)
	{
		defaultInPBinop(node);
	}


	/**
	* Called by the {@link AEquivBinop} node from {@link AEquivBinop#apply(IAnalysis)}.
	* @param node the calling {@link AEquivBinop} node
	*/
	public void outAEquivBinop(AEquivBinop node)
	{
		defaultOutPBinop(node);
	}


	/**
	* Called by the {@link AForBinop} node from {@link AForBinop#apply(IAnalysis)}.
	* @param node the calling {@link AForBinop} node
	*/
	public void caseAForBinop(AForBinop node)
	{
		if(_queue.contains(node))
		{ //already visiting this node from other path
			return;
		}
		_queue.add(node);
		inAForBinop(node);


		outAForBinop(node);
		_queue.remove(node);

	}


	/**
	* Called by the {@link AForBinop} node from {@link AForBinop#apply(IAnalysis)}.
	* @param node the calling {@link AForBinop} node
	*/
	public void inAForBinop(AForBinop node)
	{
		defaultInPBinop(node);
	}


	/**
	* Called by the {@link AForBinop} node from {@link AForBinop#apply(IAnalysis)}.
	* @param node the calling {@link AForBinop} node
	*/
	public void outAForBinop(AForBinop node)
	{
		defaultOutPBinop(node);
	}


	/**
	* Called by the {@link PDomain} node from {@link PDomain#apply(IAnalysis)}.
	* @param node the calling {@link PDomain} node
	*/
	public void defaultInPDomain(PDomain node)
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PDomain} node from {@link PDomain#apply(IAnalysis)}.
	* @param node the calling {@link PDomain} node
	*/
	public void defaultOutPDomain(PDomain node)
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link PDomain} node from {@link PDomain#apply(IAnalysis)}.
	* @param node the calling {@link PDomain} node
	*/
	public void inPDomain(PDomain node)
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PDomain} node from {@link PDomain#apply(IAnalysis)}.
	* @param node the calling {@link PDomain} node
	*/
	public void outPDomain(PDomain node)
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link ADeDomain} node from {@link ADeDomain#apply(IAnalysis)}.
	* @param node the calling {@link ADeDomain} node
	*/
	public void caseADeDomain(ADeDomain node)
	{
		if(_queue.contains(node))
		{ //already visiting this node from other path
			return;
		}
		_queue.add(node);
		inADeDomain(node);


		outADeDomain(node);
		_queue.remove(node);

	}


	/**
	* Called by the {@link ADeDomain} node from {@link ADeDomain#apply(IAnalysis)}.
	* @param node the calling {@link ADeDomain} node
	*/
	public void inADeDomain(ADeDomain node)
	{
		defaultInPDomain(node);
	}


	/**
	* Called by the {@link ADeDomain} node from {@link ADeDomain#apply(IAnalysis)}.
	* @param node the calling {@link ADeDomain} node
	*/
	public void outADeDomain(ADeDomain node)
	{
		defaultOutPDomain(node);
	}


	/**
	* Called by the {@link ACtDomain} node from {@link ACtDomain#apply(IAnalysis)}.
	* @param node the calling {@link ACtDomain} node
	*/
	public void caseACtDomain(ACtDomain node)
	{
		if(_queue.contains(node))
		{ //already visiting this node from other path
			return;
		}
		_queue.add(node);
		inACtDomain(node);


		outACtDomain(node);
		_queue.remove(node);

	}


	/**
	* Called by the {@link ACtDomain} node from {@link ACtDomain#apply(IAnalysis)}.
	* @param node the calling {@link ACtDomain} node
	*/
	public void inACtDomain(ACtDomain node)
	{
		defaultInPDomain(node);
	}


	/**
	* Called by the {@link ACtDomain} node from {@link ACtDomain#apply(IAnalysis)}.
	* @param node the calling {@link ACtDomain} node
	*/
	public void outACtDomain(ACtDomain node)
	{
		defaultOutPDomain(node);
	}


	/**
	* Called by the {@link PExp} node from {@link PExp#apply(IAnalysis)}.
	* @param node the calling {@link PExp} node
	*/
	public void defaultInPExp(PExp node)
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PExp} node from {@link PExp#apply(IAnalysis)}.
	* @param node the calling {@link PExp} node
	*/
	public void defaultOutPExp(PExp node)
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link PExp} node from {@link PExp#apply(IAnalysis)}.
	* @param node the calling {@link PExp} node
	*/
	public void inPExp(PExp node)
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PExp} node from {@link PExp#apply(IAnalysis)}.
	* @param node the calling {@link PExp} node
	*/
	public void outPExp(PExp node)
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link SSingleExp} node from {@link SSingleExp#apply(IAnalysis)}.
	* @param node the calling {@link SSingleExp} node
	*/
	public void defaultInSSingleExp(SSingleExp node)
	{
		defaultInPExp(node);
	}


	/**
	* Called by the {@link SSingleExp} node from {@link SSingleExp#apply(IAnalysis)}.
	* @param node the calling {@link SSingleExp} node
	*/
	public void defaultOutSSingleExp(SSingleExp node)
	{
		defaultOutPExp(node);
	}


	/**
	* Called by the {@link SSingleExp} node from {@link SSingleExp#apply(IAnalysis)}.
	* @param node the calling {@link SSingleExp} node
	*/
	public void inSSingleExp(SSingleExp node)
	{
		defaultInPExp(node);
	}


	/**
	* Called by the {@link SSingleExp} node from {@link SSingleExp#apply(IAnalysis)}.
	* @param node the calling {@link SSingleExp} node
	*/
	public void outSSingleExp(SSingleExp node)
	{
		defaultOutPExp(node);
	}


	/**
	* Called by the {@link AUnaryExp} node from {@link AUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AUnaryExp} node
	*/
	public void caseAUnaryExp(AUnaryExp node)
	{
		if(_queue.contains(node))
		{ //already visiting this node from other path
			return;
		}
		_queue.add(node);
		inAUnaryExp(node);

		if(node.getOperator() != null) {
			node.getOperator().apply(this);
		}
		if(node.getExp() != null) {
			node.getExp().apply(this);
		}

		outAUnaryExp(node);
		_queue.remove(node);

	}


	/**
	* Called by the {@link AUnaryExp} node from {@link AUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AUnaryExp} node
	*/
	public void inAUnaryExp(AUnaryExp node)
	{
		defaultInPExp(node);
	}


	/**
	* Called by the {@link AUnaryExp} node from {@link AUnaryExp#apply(IAnalysis)}.
	* @param node the calling {@link AUnaryExp} node
	*/
	public void outAUnaryExp(AUnaryExp node)
	{
		defaultOutPExp(node);
	}


	/**
	* Called by the {@link ABinaryExp} node from {@link ABinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ABinaryExp} node
	*/
	public void caseABinaryExp(ABinaryExp node)
	{
		if(_queue.contains(node))
		{ //already visiting this node from other path
			return;
		}
		_queue.add(node);
		inABinaryExp(node);

		if(node.getLeft() != null) {
			node.getLeft().apply(this);
		}
		if(node.getOperator() != null) {
			node.getOperator().apply(this);
		}
		if(node.getRight() != null) {
			node.getRight().apply(this);
		}

		outABinaryExp(node);
		_queue.remove(node);

	}


	/**
	* Called by the {@link ABinaryExp} node from {@link ABinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ABinaryExp} node
	*/
	public void inABinaryExp(ABinaryExp node)
	{
		defaultInPExp(node);
	}


	/**
	* Called by the {@link ABinaryExp} node from {@link ABinaryExp#apply(IAnalysis)}.
	* @param node the calling {@link ABinaryExp} node
	*/
	public void outABinaryExp(ABinaryExp node)
	{
		defaultOutPExp(node);
	}


	/**
	* Called by the {@link ABoolSingleExp} node from {@link ABoolSingleExp#apply(IAnalysis)}.
	* @param node the calling {@link ABoolSingleExp} node
	*/
	public void caseABoolSingleExp(ABoolSingleExp node)
	{
		if(_queue.contains(node))
		{ //already visiting this node from other path
			return;
		}
		_queue.add(node);
		inABoolSingleExp(node);


		outABoolSingleExp(node);
		_queue.remove(node);

	}


	/**
	* Called by the {@link ABoolSingleExp} node from {@link ABoolSingleExp#apply(IAnalysis)}.
	* @param node the calling {@link ABoolSingleExp} node
	*/
	public void inABoolSingleExp(ABoolSingleExp node)
	{
		defaultInSSingleExp(node);
	}


	/**
	* Called by the {@link ABoolSingleExp} node from {@link ABoolSingleExp#apply(IAnalysis)}.
	* @param node the calling {@link ABoolSingleExp} node
	*/
	public void outABoolSingleExp(ABoolSingleExp node)
	{
		defaultOutSSingleExp(node);
	}


	/**
	* Called by the {@link ANumericalSingleExp} node from {@link ANumericalSingleExp#apply(IAnalysis)}.
	* @param node the calling {@link ANumericalSingleExp} node
	*/
	public void caseANumericalSingleExp(ANumericalSingleExp node)
	{
		if(_queue.contains(node))
		{ //already visiting this node from other path
			return;
		}
		_queue.add(node);
		inANumericalSingleExp(node);


		outANumericalSingleExp(node);
		_queue.remove(node);

	}


	/**
	* Called by the {@link ANumericalSingleExp} node from {@link ANumericalSingleExp#apply(IAnalysis)}.
	* @param node the calling {@link ANumericalSingleExp} node
	*/
	public void inANumericalSingleExp(ANumericalSingleExp node)
	{
		defaultInSSingleExp(node);
	}


	/**
	* Called by the {@link ANumericalSingleExp} node from {@link ANumericalSingleExp#apply(IAnalysis)}.
	* @param node the calling {@link ANumericalSingleExp} node
	*/
	public void outANumericalSingleExp(ANumericalSingleExp node)
	{
		defaultOutSSingleExp(node);
	}


	/**
	* Called by the {@link ATimeSingleExp} node from {@link ATimeSingleExp#apply(IAnalysis)}.
	* @param node the calling {@link ATimeSingleExp} node
	*/
	public void caseATimeSingleExp(ATimeSingleExp node)
	{
		if(_queue.contains(node))
		{ //already visiting this node from other path
			return;
		}
		_queue.add(node);
		inATimeSingleExp(node);

		if(node.getUnit() != null) {
			node.getUnit().apply(this);
		}

		outATimeSingleExp(node);
		_queue.remove(node);

	}


	/**
	* Called by the {@link ATimeSingleExp} node from {@link ATimeSingleExp#apply(IAnalysis)}.
	* @param node the calling {@link ATimeSingleExp} node
	*/
	public void inATimeSingleExp(ATimeSingleExp node)
	{
		defaultInSSingleExp(node);
	}


	/**
	* Called by the {@link ATimeSingleExp} node from {@link ATimeSingleExp#apply(IAnalysis)}.
	* @param node the calling {@link ATimeSingleExp} node
	*/
	public void outATimeSingleExp(ATimeSingleExp node)
	{
		defaultOutSSingleExp(node);
	}


	/**
	* Called by the {@link AIdentifierSingleExp} node from {@link AIdentifierSingleExp#apply(IAnalysis)}.
	* @param node the calling {@link AIdentifierSingleExp} node
	*/
	public void caseAIdentifierSingleExp(AIdentifierSingleExp node)
	{
		if(_queue.contains(node))
		{ //already visiting this node from other path
			return;
		}
		_queue.add(node);
		inAIdentifierSingleExp(node);

		if(node.getDomain() != null) {
			node.getDomain().apply(this);
		}
		if(node.getType() != null) {
			node.getType().apply(this);
		}

		outAIdentifierSingleExp(node);
		_queue.remove(node);

	}


	/**
	* Called by the {@link AIdentifierSingleExp} node from {@link AIdentifierSingleExp#apply(IAnalysis)}.
	* @param node the calling {@link AIdentifierSingleExp} node
	*/
	public void inAIdentifierSingleExp(AIdentifierSingleExp node)
	{
		defaultInSSingleExp(node);
	}


	/**
	* Called by the {@link AIdentifierSingleExp} node from {@link AIdentifierSingleExp#apply(IAnalysis)}.
	* @param node the calling {@link AIdentifierSingleExp} node
	*/
	public void outAIdentifierSingleExp(AIdentifierSingleExp node)
	{
		defaultOutSSingleExp(node);
	}


	/**
	* Called by the {@link ASystemTimeSingleExp} node from {@link ASystemTimeSingleExp#apply(IAnalysis)}.
	* @param node the calling {@link ASystemTimeSingleExp} node
	*/
	public void caseASystemTimeSingleExp(ASystemTimeSingleExp node)
	{
		if(_queue.contains(node))
		{ //already visiting this node from other path
			return;
		}
		_queue.add(node);
		inASystemTimeSingleExp(node);


		outASystemTimeSingleExp(node);
		_queue.remove(node);

	}


	/**
	* Called by the {@link ASystemTimeSingleExp} node from {@link ASystemTimeSingleExp#apply(IAnalysis)}.
	* @param node the calling {@link ASystemTimeSingleExp} node
	*/
	public void inASystemTimeSingleExp(ASystemTimeSingleExp node)
	{
		defaultInSSingleExp(node);
	}


	/**
	* Called by the {@link ASystemTimeSingleExp} node from {@link ASystemTimeSingleExp#apply(IAnalysis)}.
	* @param node the calling {@link ASystemTimeSingleExp} node
	*/
	public void outASystemTimeSingleExp(ASystemTimeSingleExp node)
	{
		defaultOutSSingleExp(node);
	}


	/**
	* Called by the {@link PTimeunit} node from {@link PTimeunit#apply(IAnalysis)}.
	* @param node the calling {@link PTimeunit} node
	*/
	public void defaultInPTimeunit(PTimeunit node)
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PTimeunit} node from {@link PTimeunit#apply(IAnalysis)}.
	* @param node the calling {@link PTimeunit} node
	*/
	public void defaultOutPTimeunit(PTimeunit node)
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link PTimeunit} node from {@link PTimeunit#apply(IAnalysis)}.
	* @param node the calling {@link PTimeunit} node
	*/
	public void inPTimeunit(PTimeunit node)
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PTimeunit} node from {@link PTimeunit#apply(IAnalysis)}.
	* @param node the calling {@link PTimeunit} node
	*/
	public void outPTimeunit(PTimeunit node)
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link AUsTimeunit} node from {@link AUsTimeunit#apply(IAnalysis)}.
	* @param node the calling {@link AUsTimeunit} node
	*/
	public void caseAUsTimeunit(AUsTimeunit node)
	{
		if(_queue.contains(node))
		{ //already visiting this node from other path
			return;
		}
		_queue.add(node);
		inAUsTimeunit(node);


		outAUsTimeunit(node);
		_queue.remove(node);

	}


	/**
	* Called by the {@link AUsTimeunit} node from {@link AUsTimeunit#apply(IAnalysis)}.
	* @param node the calling {@link AUsTimeunit} node
	*/
	public void inAUsTimeunit(AUsTimeunit node)
	{
		defaultInPTimeunit(node);
	}


	/**
	* Called by the {@link AUsTimeunit} node from {@link AUsTimeunit#apply(IAnalysis)}.
	* @param node the calling {@link AUsTimeunit} node
	*/
	public void outAUsTimeunit(AUsTimeunit node)
	{
		defaultOutPTimeunit(node);
	}


	/**
	* Called by the {@link AMsTimeunit} node from {@link AMsTimeunit#apply(IAnalysis)}.
	* @param node the calling {@link AMsTimeunit} node
	*/
	public void caseAMsTimeunit(AMsTimeunit node)
	{
		if(_queue.contains(node))
		{ //already visiting this node from other path
			return;
		}
		_queue.add(node);
		inAMsTimeunit(node);


		outAMsTimeunit(node);
		_queue.remove(node);

	}


	/**
	* Called by the {@link AMsTimeunit} node from {@link AMsTimeunit#apply(IAnalysis)}.
	* @param node the calling {@link AMsTimeunit} node
	*/
	public void inAMsTimeunit(AMsTimeunit node)
	{
		defaultInPTimeunit(node);
	}


	/**
	* Called by the {@link AMsTimeunit} node from {@link AMsTimeunit#apply(IAnalysis)}.
	* @param node the calling {@link AMsTimeunit} node
	*/
	public void outAMsTimeunit(AMsTimeunit node)
	{
		defaultOutPTimeunit(node);
	}


	/**
	* Called by the {@link ASTimeunit} node from {@link ASTimeunit#apply(IAnalysis)}.
	* @param node the calling {@link ASTimeunit} node
	*/
	public void caseASTimeunit(ASTimeunit node)
	{
		if(_queue.contains(node))
		{ //already visiting this node from other path
			return;
		}
		_queue.add(node);
		inASTimeunit(node);


		outASTimeunit(node);
		_queue.remove(node);

	}


	/**
	* Called by the {@link ASTimeunit} node from {@link ASTimeunit#apply(IAnalysis)}.
	* @param node the calling {@link ASTimeunit} node
	*/
	public void inASTimeunit(ASTimeunit node)
	{
		defaultInPTimeunit(node);
	}


	/**
	* Called by the {@link ASTimeunit} node from {@link ASTimeunit#apply(IAnalysis)}.
	* @param node the calling {@link ASTimeunit} node
	*/
	public void outASTimeunit(ASTimeunit node)
	{
		defaultOutPTimeunit(node);
	}


	/**
	* Called by the {@link AMTimeunit} node from {@link AMTimeunit#apply(IAnalysis)}.
	* @param node the calling {@link AMTimeunit} node
	*/
	public void caseAMTimeunit(AMTimeunit node)
	{
		if(_queue.contains(node))
		{ //already visiting this node from other path
			return;
		}
		_queue.add(node);
		inAMTimeunit(node);


		outAMTimeunit(node);
		_queue.remove(node);

	}


	/**
	* Called by the {@link AMTimeunit} node from {@link AMTimeunit#apply(IAnalysis)}.
	* @param node the calling {@link AMTimeunit} node
	*/
	public void inAMTimeunit(AMTimeunit node)
	{
		defaultInPTimeunit(node);
	}


	/**
	* Called by the {@link AMTimeunit} node from {@link AMTimeunit#apply(IAnalysis)}.
	* @param node the calling {@link AMTimeunit} node
	*/
	public void outAMTimeunit(AMTimeunit node)
	{
		defaultOutPTimeunit(node);
	}


	/**
	* Called by the {@link AHTimeunit} node from {@link AHTimeunit#apply(IAnalysis)}.
	* @param node the calling {@link AHTimeunit} node
	*/
	public void caseAHTimeunit(AHTimeunit node)
	{
		if(_queue.contains(node))
		{ //already visiting this node from other path
			return;
		}
		_queue.add(node);
		inAHTimeunit(node);


		outAHTimeunit(node);
		_queue.remove(node);

	}


	/**
	* Called by the {@link AHTimeunit} node from {@link AHTimeunit#apply(IAnalysis)}.
	* @param node the calling {@link AHTimeunit} node
	*/
	public void inAHTimeunit(AHTimeunit node)
	{
		defaultInPTimeunit(node);
	}


	/**
	* Called by the {@link AHTimeunit} node from {@link AHTimeunit#apply(IAnalysis)}.
	* @param node the calling {@link AHTimeunit} node
	*/
	public void outAHTimeunit(AHTimeunit node)
	{
		defaultOutPTimeunit(node);
	}


	/**
	* Called by the {@link PStm} node from {@link PStm#apply(IAnalysis)}.
	* @param node the calling {@link PStm} node
	*/
	public void defaultInPStm(PStm node)
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PStm} node from {@link PStm#apply(IAnalysis)}.
	* @param node the calling {@link PStm} node
	*/
	public void defaultOutPStm(PStm node)
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link PStm} node from {@link PStm#apply(IAnalysis)}.
	* @param node the calling {@link PStm} node
	*/
	public void inPStm(PStm node)
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PStm} node from {@link PStm#apply(IAnalysis)}.
	* @param node the calling {@link PStm} node
	*/
	public void outPStm(PStm node)
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link AWhenStm} node from {@link AWhenStm#apply(IAnalysis)}.
	* @param node the calling {@link AWhenStm} node
	*/
	public void caseAWhenStm(AWhenStm node)
	{
		if(_queue.contains(node))
		{ //already visiting this node from other path
			return;
		}
		_queue.add(node);
		inAWhenStm(node);

		if(node.getTest() != null) {
			node.getTest().apply(this);
		}
		{
			List<PStm> copy = new ArrayList<PStm>(node.getThen());
			for( PStm e : copy) {
				e.apply(this);
			}
		}
		{
			List<ARevertStm> copy = new ArrayList<ARevertStm>(node.getAfter());
			for( ARevertStm e : copy) {
				e.apply(this);
			}
		}

		outAWhenStm(node);
		_queue.remove(node);

	}


	/**
	* Called by the {@link AWhenStm} node from {@link AWhenStm#apply(IAnalysis)}.
	* @param node the calling {@link AWhenStm} node
	*/
	public void inAWhenStm(AWhenStm node)
	{
		defaultInPStm(node);
	}


	/**
	* Called by the {@link AWhenStm} node from {@link AWhenStm#apply(IAnalysis)}.
	* @param node the calling {@link AWhenStm} node
	*/
	public void outAWhenStm(AWhenStm node)
	{
		defaultOutPStm(node);
	}


	/**
	* Called by the {@link AAssignStm} node from {@link AAssignStm#apply(IAnalysis)}.
	* @param node the calling {@link AAssignStm} node
	*/
	public void caseAAssignStm(AAssignStm node)
	{
		if(_queue.contains(node))
		{ //already visiting this node from other path
			return;
		}
		_queue.add(node);
		inAAssignStm(node);

		if(node.getDomain() != null) {
			node.getDomain().apply(this);
		}
		if(node.getValue() != null) {
			node.getValue().apply(this);
		}

		outAAssignStm(node);
		_queue.remove(node);

	}


	/**
	* Called by the {@link AAssignStm} node from {@link AAssignStm#apply(IAnalysis)}.
	* @param node the calling {@link AAssignStm} node
	*/
	public void inAAssignStm(AAssignStm node)
	{
		defaultInPStm(node);
	}


	/**
	* Called by the {@link AAssignStm} node from {@link AAssignStm#apply(IAnalysis)}.
	* @param node the calling {@link AAssignStm} node
	*/
	public void outAAssignStm(AAssignStm node)
	{
		defaultOutPStm(node);
	}


	/**
	* Called by the {@link ARevertStm} node from {@link ARevertStm#apply(IAnalysis)}.
	* @param node the calling {@link ARevertStm} node
	*/
	public void caseARevertStm(ARevertStm node)
	{
		if(_queue.contains(node))
		{ //already visiting this node from other path
			return;
		}
		_queue.add(node);
		inARevertStm(node);


		outARevertStm(node);
		_queue.remove(node);

	}


	/**
	* Called by the {@link ARevertStm} node from {@link ARevertStm#apply(IAnalysis)}.
	* @param node the calling {@link ARevertStm} node
	*/
	public void inARevertStm(ARevertStm node)
	{
		defaultInPStm(node);
	}


	/**
	* Called by the {@link ARevertStm} node from {@link ARevertStm#apply(IAnalysis)}.
	* @param node the calling {@link ARevertStm} node
	*/
	public void outARevertStm(ARevertStm node)
	{
		defaultOutPStm(node);
	}


	/**
	* Called by the {@link SMessageStm} node from {@link SMessageStm#apply(IAnalysis)}.
	* @param node the calling {@link SMessageStm} node
	*/
	public void defaultInSMessageStm(SMessageStm node)
	{
		defaultInPStm(node);
	}


	/**
	* Called by the {@link SMessageStm} node from {@link SMessageStm#apply(IAnalysis)}.
	* @param node the calling {@link SMessageStm} node
	*/
	public void defaultOutSMessageStm(SMessageStm node)
	{
		defaultOutPStm(node);
	}


	/**
	* Called by the {@link SMessageStm} node from {@link SMessageStm#apply(IAnalysis)}.
	* @param node the calling {@link SMessageStm} node
	*/
	public void inSMessageStm(SMessageStm node)
	{
		defaultInPStm(node);
	}


	/**
	* Called by the {@link SMessageStm} node from {@link SMessageStm#apply(IAnalysis)}.
	* @param node the calling {@link SMessageStm} node
	*/
	public void outSMessageStm(SMessageStm node)
	{
		defaultOutPStm(node);
	}


	/**
	* Called by the {@link AQuitStm} node from {@link AQuitStm#apply(IAnalysis)}.
	* @param node the calling {@link AQuitStm} node
	*/
	public void caseAQuitStm(AQuitStm node)
	{
		if(_queue.contains(node))
		{ //already visiting this node from other path
			return;
		}
		_queue.add(node);
		inAQuitStm(node);


		outAQuitStm(node);
		_queue.remove(node);

	}


	/**
	* Called by the {@link AQuitStm} node from {@link AQuitStm#apply(IAnalysis)}.
	* @param node the calling {@link AQuitStm} node
	*/
	public void inAQuitStm(AQuitStm node)
	{
		defaultInPStm(node);
	}


	/**
	* Called by the {@link AQuitStm} node from {@link AQuitStm#apply(IAnalysis)}.
	* @param node the calling {@link AQuitStm} node
	*/
	public void outAQuitStm(AQuitStm node)
	{
		defaultOutPStm(node);
	}


	/**
	* Called by the {@link APrintMessageStm} node from {@link APrintMessageStm#apply(IAnalysis)}.
	* @param node the calling {@link APrintMessageStm} node
	*/
	public void caseAPrintMessageStm(APrintMessageStm node)
	{
		if(_queue.contains(node))
		{ //already visiting this node from other path
			return;
		}
		_queue.add(node);
		inAPrintMessageStm(node);


		outAPrintMessageStm(node);
		_queue.remove(node);

	}


	/**
	* Called by the {@link APrintMessageStm} node from {@link APrintMessageStm#apply(IAnalysis)}.
	* @param node the calling {@link APrintMessageStm} node
	*/
	public void inAPrintMessageStm(APrintMessageStm node)
	{
		defaultInSMessageStm(node);
	}


	/**
	* Called by the {@link APrintMessageStm} node from {@link APrintMessageStm#apply(IAnalysis)}.
	* @param node the calling {@link APrintMessageStm} node
	*/
	public void outAPrintMessageStm(APrintMessageStm node)
	{
		defaultOutSMessageStm(node);
	}


	/**
	* Called by the {@link AErrorMessageStm} node from {@link AErrorMessageStm#apply(IAnalysis)}.
	* @param node the calling {@link AErrorMessageStm} node
	*/
	public void caseAErrorMessageStm(AErrorMessageStm node)
	{
		if(_queue.contains(node))
		{ //already visiting this node from other path
			return;
		}
		_queue.add(node);
		inAErrorMessageStm(node);


		outAErrorMessageStm(node);
		_queue.remove(node);

	}


	/**
	* Called by the {@link AErrorMessageStm} node from {@link AErrorMessageStm#apply(IAnalysis)}.
	* @param node the calling {@link AErrorMessageStm} node
	*/
	public void inAErrorMessageStm(AErrorMessageStm node)
	{
		defaultInSMessageStm(node);
	}


	/**
	* Called by the {@link AErrorMessageStm} node from {@link AErrorMessageStm#apply(IAnalysis)}.
	* @param node the calling {@link AErrorMessageStm} node
	*/
	public void outAErrorMessageStm(AErrorMessageStm node)
	{
		defaultOutSMessageStm(node);
	}


	/**
	* Called by the {@link AWarnMessageStm} node from {@link AWarnMessageStm#apply(IAnalysis)}.
	* @param node the calling {@link AWarnMessageStm} node
	*/
	public void caseAWarnMessageStm(AWarnMessageStm node)
	{
		if(_queue.contains(node))
		{ //already visiting this node from other path
			return;
		}
		_queue.add(node);
		inAWarnMessageStm(node);


		outAWarnMessageStm(node);
		_queue.remove(node);

	}


	/**
	* Called by the {@link AWarnMessageStm} node from {@link AWarnMessageStm#apply(IAnalysis)}.
	* @param node the calling {@link AWarnMessageStm} node
	*/
	public void inAWarnMessageStm(AWarnMessageStm node)
	{
		defaultInSMessageStm(node);
	}


	/**
	* Called by the {@link AWarnMessageStm} node from {@link AWarnMessageStm#apply(IAnalysis)}.
	* @param node the calling {@link AWarnMessageStm} node
	*/
	public void outAWarnMessageStm(AWarnMessageStm node)
	{
		defaultOutSMessageStm(node);
	}


	/**
	* Called by the {@link PType} node from {@link PType#apply(IAnalysis)}.
	* @param node the calling {@link PType} node
	*/
	public void defaultInPType(PType node)
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PType} node from {@link PType#apply(IAnalysis)}.
	* @param node the calling {@link PType} node
	*/
	public void defaultOutPType(PType node)
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link PType} node from {@link PType#apply(IAnalysis)}.
	* @param node the calling {@link PType} node
	*/
	public void inPType(PType node)
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PType} node from {@link PType#apply(IAnalysis)}.
	* @param node the calling {@link PType} node
	*/
	public void outPType(PType node)
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link ARealType} node from {@link ARealType#apply(IAnalysis)}.
	* @param node the calling {@link ARealType} node
	*/
	public void caseARealType(ARealType node)
	{
		if(_queue.contains(node))
		{ //already visiting this node from other path
			return;
		}
		_queue.add(node);
		inARealType(node);


		outARealType(node);
		_queue.remove(node);

	}


	/**
	* Called by the {@link ARealType} node from {@link ARealType#apply(IAnalysis)}.
	* @param node the calling {@link ARealType} node
	*/
	public void inARealType(ARealType node)
	{
		defaultInPType(node);
	}


	/**
	* Called by the {@link ARealType} node from {@link ARealType#apply(IAnalysis)}.
	* @param node the calling {@link ARealType} node
	*/
	public void outARealType(ARealType node)
	{
		defaultOutPType(node);
	}


	/**
	* Called by the {@link AIntType} node from {@link AIntType#apply(IAnalysis)}.
	* @param node the calling {@link AIntType} node
	*/
	public void caseAIntType(AIntType node)
	{
		if(_queue.contains(node))
		{ //already visiting this node from other path
			return;
		}
		_queue.add(node);
		inAIntType(node);


		outAIntType(node);
		_queue.remove(node);

	}


	/**
	* Called by the {@link AIntType} node from {@link AIntType#apply(IAnalysis)}.
	* @param node the calling {@link AIntType} node
	*/
	public void inAIntType(AIntType node)
	{
		defaultInPType(node);
	}


	/**
	* Called by the {@link AIntType} node from {@link AIntType#apply(IAnalysis)}.
	* @param node the calling {@link AIntType} node
	*/
	public void outAIntType(AIntType node)
	{
		defaultOutPType(node);
	}


	/**
	* Called by the {@link ABoolType} node from {@link ABoolType#apply(IAnalysis)}.
	* @param node the calling {@link ABoolType} node
	*/
	public void caseABoolType(ABoolType node)
	{
		if(_queue.contains(node))
		{ //already visiting this node from other path
			return;
		}
		_queue.add(node);
		inABoolType(node);


		outABoolType(node);
		_queue.remove(node);

	}


	/**
	* Called by the {@link ABoolType} node from {@link ABoolType#apply(IAnalysis)}.
	* @param node the calling {@link ABoolType} node
	*/
	public void inABoolType(ABoolType node)
	{
		defaultInPType(node);
	}


	/**
	* Called by the {@link ABoolType} node from {@link ABoolType#apply(IAnalysis)}.
	* @param node the calling {@link ABoolType} node
	*/
	public void outABoolType(ABoolType node)
	{
		defaultOutPType(node);
	}


	/**
	* Called by the {@link ATimeType} node from {@link ATimeType#apply(IAnalysis)}.
	* @param node the calling {@link ATimeType} node
	*/
	public void caseATimeType(ATimeType node)
	{
		if(_queue.contains(node))
		{ //already visiting this node from other path
			return;
		}
		_queue.add(node);
		inATimeType(node);


		outATimeType(node);
		_queue.remove(node);

	}


	/**
	* Called by the {@link ATimeType} node from {@link ATimeType#apply(IAnalysis)}.
	* @param node the calling {@link ATimeType} node
	*/
	public void inATimeType(ATimeType node)
	{
		defaultInPType(node);
	}


	/**
	* Called by the {@link ATimeType} node from {@link ATimeType#apply(IAnalysis)}.
	* @param node the calling {@link ATimeType} node
	*/
	public void outATimeType(ATimeType node)
	{
		defaultOutPType(node);
	}


	/**
	* Called by the {@link PInclude} node from {@link PInclude#apply(IAnalysis)}.
	* @param node the calling {@link PInclude} node
	*/
	public void defaultInPInclude(PInclude node)
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PInclude} node from {@link PInclude#apply(IAnalysis)}.
	* @param node the calling {@link PInclude} node
	*/
	public void defaultOutPInclude(PInclude node)
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link PInclude} node from {@link PInclude#apply(IAnalysis)}.
	* @param node the calling {@link PInclude} node
	*/
	public void inPInclude(PInclude node)
	{
		defaultInINode(node);
	}


	/**
	* Called by the {@link PInclude} node from {@link PInclude#apply(IAnalysis)}.
	* @param node the calling {@link PInclude} node
	*/
	public void outPInclude(PInclude node)
	{
		defaultOutINode(node);
	}


	/**
	* Called by the {@link AScriptInclude} node from {@link AScriptInclude#apply(IAnalysis)}.
	* @param node the calling {@link AScriptInclude} node
	*/
	public void caseAScriptInclude(AScriptInclude node)
	{
		if(_queue.contains(node))
		{ //already visiting this node from other path
			return;
		}
		_queue.add(node);
		inAScriptInclude(node);


		outAScriptInclude(node);
		_queue.remove(node);

	}


	/**
	* Called by the {@link AScriptInclude} node from {@link AScriptInclude#apply(IAnalysis)}.
	* @param node the calling {@link AScriptInclude} node
	*/
	public void inAScriptInclude(AScriptInclude node)
	{
		defaultInPInclude(node);
	}


	/**
	* Called by the {@link AScriptInclude} node from {@link AScriptInclude#apply(IAnalysis)}.
	* @param node the calling {@link AScriptInclude} node
	*/
	public void outAScriptInclude(AScriptInclude node)
	{
		defaultOutPInclude(node);
	}


	/**
	* Called by the {@link INode} node from {@link INode#apply(IAnalysis)}.
	* @param node the calling {@link INode} node
	*/
	public void defaultOutINode(INode node)
	{
		//nothing to do
	}


	/**
	* Called by the {@link INode} node from {@link INode#apply(IAnalysis)}.
	* @param node the calling {@link INode} node
	*/
	public void defaultInINode(INode node)
	{
		//nothing to do
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void defaultOutIToken(IToken node)
	{
		//nothing to do
	}


	/**
	* Called by the {@link IToken} node from {@link IToken#apply(IAnalysis)}.
	* @param node the calling {@link IToken} node
	*/
	public void defaultInIToken(IToken node)
	{
		//nothing to do
	}



}
